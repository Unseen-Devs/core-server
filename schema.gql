# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type PageInfo {
  startCursor: String
  endCursor: String
  hasPrevPage: Boolean!
  hasNextPage: Boolean!
}

type BasePaginationMeta {
  itemCount: Float!
  totalItems: Float!
  itemsPerPage: Float!
  totalPages: Float!
  currentPage: Float!
}

"""Opta"""
type Opta implements Node {
  id: ID!
  title: String!
  isPublished: Boolean!
  ownerId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Node"""
interface Node {
  id: ID!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type TournamentCalendarInfo {
  id: String
  includesVenues: String
  ocId: String
  name: String
  startDate: String
  endDate: String
  active: String
  lastUpdated: DateTime
  includesStandings: String
}

type CompetitionModel {
  id: String
  ocId: String
  opId: String
  name: String
  competitionCode: String
  displayOrder: Float
  country: String
  countryId: String
  countryCode: String
  isFriendly: String
  competitionFormat: String
  type: String
  tournamentCalendar: [TournamentCalendarInfo!]
  competitionType: String
}

type TournamentCalendarModel {
  competition: [CompetitionModel!]
  lastUpdated: DateTime!
}

type GoalModel {
  contestantId: String
  periodId: Float
  timeMin: Float
  timeMinSec: String
  lastUpdated: String
  timestamp: String
  type: String
  scorerId: String
  scorerName: String
  scorerPlayerTouch: Float
  assistPlayerId: String
  assistPlayerName: String
  assistPlayerTouch: Float
  optaEventId: String
  homeScore: Float
  awayScore: Float
  varReviewed: String
  originalDecision: String
}

type ScoreModel {
  home: Float
  away: Float
}

type ScoresModel {
  ht: ScoreModel
  ft: ScoreModel
  total: ScoreModel
}

type MatchInfoModel {
  id: String
  date: String
  time: String
  contestant: [MatchContestantModel!]
  matchStatus: FixtureStatus
  scores: ScoresModel
  goal: [GoalModel!]
}

enum FixtureStatus {
  Fixture
  Played
  Playing
  Cancelled
  Postponed
  Suspended
  All
}

type MatchContestantModel {
  id: String
  name: String
  shortName: String
  officialName: String
  code: String
  position: String
}

type FixturesModelAndResultsModel {
  match: [MatchInfoModel!]
}

type TournamentScheduleDetailModel {
  id: String
  coverageLevel: String
  optaBetting: String
  date: String
  time: String
  localDate: String
  localTime: String
  homeContestantId: String
  awayContestantId: String
  homeContestantName: String
  awayContestantName: String
  homeContestantOfficialName: String
  awayContestantOfficialName: String
  homeContestantShortName: String
  awayContestantShortName: String
  homeContestantCode: String
  awayContestantCode: String
  numberOfPeriods: Float
  periodLength: Float
}

type TournamentScheduleModel {
  schedule: [TournamentScheduleDetailModel!]
}

type MatchEventGoal {
  contestantId: String
  periodId: Float
  timeMin: Float
  timeMinSec: String
  lastUpdated: String
  timestamp: String
  type: String
  scorerId: String
  scorerName: String
  assistPlayerId: String
  assistPlayerName: String
  secondAssistPlayerId: String
  ocSecondAssistPlayerId: String
  opSecondAssistPlayerId: String
  secondAssistPlayerName: String
  optaEventId: String
  homeScore: Float
  awayScore: Float
}

type MatchEventModel {
  description: String
  contestant: [MatchContestantModel!]
  goal: [MatchEventGoal!]
}

type MatchEventQualifierModel {
  id: Float
  qualifierId: Float
  value: String
}

type MatchEventEventModel {
  id: Float
  eventId: Float
  typeId: Int
  periodId: Int
  timeMin: Int
  timeSec: Int
  contestantId: String
  playerId: String
  playerName: String
  outcome: Float
  x: Float
  y: Float
  timeStamp: String
  lastModified: String
  qualifier: [MatchEventQualifierModel!]
}

type MatchEventMA3Model {
  description: String
  contestant: [MatchContestantModel!]
  event: [MatchEventEventModel!]
}

"""Club"""
type Club implements Node {
  id: ID!
  code: String!
  name: String!
  optaId: String
  players: [Player!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EventInfo {
  eventId: String!
  typeId: String!
  timeMin: Int!
  timeSec: Int!
  outcome: Int!
  assist: Int!
  touch: Int!
}

"""Event"""
type Event implements Node {
  id: ID!
  fixtureUuid: String
  eventInfo: EventInfo
  totalTouch: Float
  description: String
  player: Player!
}

"""Player"""
type Player implements Node {
  id: ID!
  playerId: String
  contestantId: String
  firstName: String
  lastName: String
  shortFirstName: String
  shortLastName: String
  shirtPlayer: String
  matchName: String
  type: PlayerTier
  shirtNumber: Int
  position: String
  positionSide: String
  formationPlace: String
  touch: Float
  optaId: String
  club: Club!
  events: [Event!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  player: Player
}

enum PlayerTier {
  TIER1
  TIER2
}

type PlayerConnection {
  items: [Player!]
  meta: BasePaginationMeta!
}

type EventHistoryInfo {
  eventId: String!
  typeId: String!
  timeMin: Int!
  timeSec: Int!
  outcome: Int!
  assist: Int!
  touch: Int!
}

"""Event History"""
type EventHistory implements Node {
  id: ID!
  fixtureUuid: String
  eventInfo: EventHistoryInfo
  totalTouch: Float
  playerNftId: String
  walletAddress: String
  description: String
  playerNFT: PlayerNft!
}

"""PlayerNft"""
type PlayerNft implements Node {
  id: ID!
  tokenId: String
  rewardCode: Float
  transactionHash: String
  walletAddress: String
  playerId: String
  eventHistory: [EventHistory!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  player: Player
}

"""Reward"""
type Reward implements Node {
  id: ID!
  rewardAmount: Float
  rewardType: RewardType
  transactionId: String
  tokenId: String
  status: RewardStatus
  walletAddress: String
  playerNftTokenId: String
  createdAt: DateTime!
  updatedAt: DateTime!
  playerNft: Player
}

enum RewardType {
  Touch
}

enum RewardStatus {
  Completed
}

type User implements Node {
  id: ID!
  walletAddress: String
  nonce: String
  accesstoken: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  items: [User!]
  meta: BasePaginationMeta!
}

type SinatureResponse {
  message: String!
  messageHash: String!
  signature: String!
  v: String!
  r: String!
  s: String!
}

type Query {
  getTournamentCalendar: TournamentCalendarModel
  getTournamentSchedule: TournamentScheduleModel
  getFixturesAndResults(status: FixtureStatus!, mtMDt: String!): FixturesModelAndResultsModel
  getMatchEvents(fixtureId: String!): MatchEventModel
  getMatchEventsMA3: MatchEventMA3Model

  """Require `LIST_USER` permission"""
  users(limit: Int = 15, page: Int = 1, filters: [JSONObject!], sort: SortInput, s: String): UserConnection
  getPlayers(limit: Int = 15, page: Int = 1, filters: [JSONObject!], walletAddress: String): PlayerConnection
  getPlayer(id: String!): Player
  getPlayerByWallet(walletAddress: String!, id: String!): Player
  getPlayersByWallet(walletAddress: String!): [Player!]
  generatePlayer: [Player!]
  getPlayerNftsByWallet(walletAddress: String!): [PlayerNft!]
  getRewardByWallet(walletAddress: String!): [Reward!]!
  getRewardByWalletAndType(walletAddress: String!, rewardType: RewardType): Reward!
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

input SortInput {
  field: String!
  direction: String
}

type Mutation {
  """Create user by wallet address"""
  createUser(input: NewUserWalletInput!): User
  genPlayerNft(walletAddress: String!, type: PlayerTier!, tokenId: String!, transactionHash: String!): PlayerNft
  generateAkshunStoreSignature(walletAddress: String!): SinatureResponse
}

input NewUserWalletInput {
  walletAddress: String!
}